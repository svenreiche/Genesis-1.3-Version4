/*
 * Demo plugin for field diagnostics.
 *
 * Computes power for every slice and integration step.
 *
 * C. Lechner, EuXFEL
 */

#define PLUGIN_TEST

#include <iostream>
#include <fstream>
#include <sstream>
#include <math.h>
#include <unistd.h>

#include "DiagFieldPowerDemo.h"

using namespace std;

#ifdef PLUGIN_TEST
unsigned long long call_count = 0;
#endif

extern "C" DiagFieldHookedBase *factory(void)
{
	DiagFieldHookedBase *p = new DiagFieldHookedDemo;

	return(p);
}

extern "C" void destroy(DiagFieldHookedBase *p)
{
	delete p;
}

#ifdef PLUGIN_TEST
// helper function to drop info file for testing
void generate_file(const string fn, bool write_stats=false)
{
	ofstream ofs;
	
	// Note: already existing files are truncated
	ofs.open(fn, ofstream::out);
	if(!ofs) {
		cout << "error generating file " << fn << endl;
	}
	if(write_stats) {
		ofs << "call count: " << call_count << endl;
	}
	ofs.close();
}
#endif

DiagFieldHookedDemo::DiagFieldHookedDemo()
{
#ifdef PLUGIN_TEST
	// Generate info file:
	// . note that at this point the MPI rank was not communicated to the plugin yet (avoid calling MPI function from the plugin if not really needed)
	// . using the PID instead, but note that when running on multiple computers there may be processes with identical PIDs on different system -> then the total number of generated files is smaller than MPIsize
	stringstream ss;
	ss << "plugin_constr_pid.";
	ss << getpid();
	generate_file(ss.str());
#endif
}
DiagFieldHookedDemo::~DiagFieldHookedDemo()
{
#ifdef PLUGIN_TEST
	// Generate info file:
	// to be consistent with constructor info file, use the PID here (see remark in constructor)
	stringstream ss;
	ss << "plugin_destr_pid.";
	ss << getpid();
	generate_file(ss.str(), true /* write statistical infos into the file */);
#endif
}

// After calling this function, a copy of returned obj_names should be generated by caller (it might change/become invalid at a later time)
bool DiagFieldHookedDemo::get_infos(DiagFieldHookInfos *pi)
{
	my_obj_names.clear();
	my_obj_names.push_back("my_power");
	my_obj_names.push_back("abc");
	pi->obj_names = &my_obj_names;
	pi->info_txt = "Demo for plugin diagnostics";

	return(true);
}

void DiagFieldHookedDemo::doit(DiagFieldHookData *pd)
{
	/* ALWAYS AS FIRST STEP: check version of data structure (and if the data layout is what we expect). This crashes the program if there is a mismatch. */
	verify_datastructure(pd);

#ifdef PLUGIN_TEST
	call_count++;
#endif

	if((pd->verbose) && (pd->mpi_rank==0)) {
		cout << "DiagFieldHookedDemo: "
		     << "iz=" << pd->iz
		     << ", is=" << pd->is
		     << ", harm=" << pd->harm
		     << ", ngrid=" << pd->ngrid << endl;
	}

	int iy, ix;
	complex<double> loc = 0;
	double wei = 0;
	double sum = 0;
	for(iy=0; iy<pd->ngrid; iy++) {
		for(ix=0; ix<pd->ngrid; ix++) {
			int idx = iy*pd->ngrid+ix; // see for instance src/Core/Diagnostic.cpp, function 'DiagField::getTags' (commit id efcc090)

			loc = pd->datain->at(idx);
			wei = loc.real()*loc.real() + loc.imag()*loc.imag();
			sum += wei;
		}
	}

	double power = scale_to_power(pd, sum);

	/* data organization as in the obj_names provided by calling 'get_infos' */
	pd->dataout->at(0) = power; // this goes to 'my_power'
	pd->dataout->at(1) = 42.;   // this goes to 'abc'
}
