/*
 * Demo plugin for field diagnostics.
 *
 * Computes power for every slice and integration step.
 * If the environment variable G4_PLUGIN_TESTMODE is present, additional
 * statistical debugging information for testing is written to small files
 * in the current working directory.
 *
 * C. Lechner, EuXFEL
 */

#define PLUGIN_TEST

#include <iostream>
#include <fstream>
#include <sstream>
#include <math.h>
#include <unistd.h>

#include "DiagFieldPowerDemo.h"

using namespace std;

// call count (interesting for tests of plugin system)
unsigned long long call_count = 0;

extern "C" DiagFieldHookedBase *factory(void)
{
	DiagFieldHookedBase *p = new DiagFieldHookedDemo;

	return(p);
}

extern "C" void destroy(DiagFieldHookedBase *p)
{
	delete p;
}

bool test_isactive(void)
{
	const char *p = getenv("G4_PLUGIN_TESTMODE");
	if(p)
		return(true);

	return(false);
}

// helper function to drop info file for testing
void test_generate_file(const string fn, bool write_stats=false)
{
	ofstream ofs;
	
	// Note: already existing files are truncated
	ofs.open(fn, ofstream::out);
	if(!ofs) {
		cout << "error generating file " << fn << endl;
	}
	if(write_stats) {
		ofs << "call count: " << call_count << endl;
	}
	ofs.close();
}

DiagFieldHookedDemo::DiagFieldHookedDemo()
{
	if(test_isactive()) {
		// Generate info file:
		// . note that at this point the MPI rank was not communicated to the plugin yet (avoid calling MPI function from the plugin if not really needed)
		// . using the PID instead, but note that when running on multiple computers there may be processes with identical PIDs on different system -> then the total number of generated files is smaller than MPIsize
		stringstream ss;
		ss << "plugin_constr_pid.";
		ss << getpid();
		test_generate_file(ss.str());
	}
}
DiagFieldHookedDemo::~DiagFieldHookedDemo()
{
	if(test_isactive()) {
		// Generate info file:
		// to be consistent with constructor info file, use the PID here (see remark in constructor)
		stringstream ss;
		ss << "plugin_destr_pid.";
		ss << getpid();
		test_generate_file(ss.str(), true /* write statistical infos into the file */);
	}
}

// After calling this function, a copy of returned obj_names should be generated by caller (it might change/become invalid at a later time)
bool DiagFieldHookedDemo::get_infos(DiagFieldHookInfos *pi)
{
	my_obj_names.clear();
	my_obj_names.push_back("my_power");
	my_obj_names.push_back("abc");
	pi->obj_names = &my_obj_names;
	pi->info_txt = "Demo for plugin diagnostics";

	return(true);
}

void DiagFieldHookedDemo::doit(DiagFieldHookData *pd)
{
	/* ALWAYS AS FIRST STEP: check version of data structure (and if the data layout is what we expect). This crashes the program if there is a mismatch. */
	verify_datastructure(pd);

	// count number of calls, but write out numbers only if enabled by user
	call_count++;

	if((pd->verbose) && (pd->mpi_rank==0)) {
		cout << "DiagFieldHookedDemo: "
		     << "iz=" << pd->iz
		     << ", is=" << pd->is
		     << ", harm=" << pd->harm
		     << ", ngrid=" << pd->ngrid << endl;
	}

	int iy, ix;
	complex<double> loc = 0;
	double wei = 0;
	double sum = 0;
	for(iy=0; iy<pd->ngrid; iy++) {
		for(ix=0; ix<pd->ngrid; ix++) {
			int idx = iy*pd->ngrid+ix; // see for instance src/Core/Diagnostic.cpp, function 'DiagField::getTags' (commit id efcc090)

			loc = pd->datain->at(idx);
			wei = loc.real()*loc.real() + loc.imag()*loc.imag();
			sum += wei;
		}
	}

	double power = scale_to_power(pd, sum);

	/* data organization as in the obj_names provided by calling 'get_infos' */
	pd->dataout->at(0) = power; // this goes to 'my_power'
	pd->dataout->at(1) = 42.;   // this goes to 'abc'
}
